/**
 * Unilabel type imageboard
 *
 * @author      Andreas Schenkel
 * @copyright   Andreas Schenkel {@link https://github.com/andreasschenkel}
 * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

import * as Str from 'core/str';

/**
 * @param {string} cmid
 * @param {string} canvaswidth
 * @param {string} canvasheight
 * @param {boolean} autoscale
 * @param {boolean} showgrid
 */
export const init = (cmid, canvaswidth, canvasheight, autoscale, showgrid) => {
    if (autoscale === true) {
        window.addEventListener("resize", function() {
            resize(cmid, canvaswidth, canvasheight);
        });
        resize(cmid, canvaswidth, canvasheight);
    }

    // Add eventlistener that toggles the 50x50px helpergrid on and off
    const gridtoggler = document.getElementById("unilabeltype-imageboard-gridtoggler-" + cmid);
    const helpergrid = document.getElementById("unilabeltype-imageboard-helpergrid-" + cmid);

    if (showgrid === true) {
        showGrid(gridtoggler, helpergrid);
    }

    gridtoggler.addEventListener("click", function(event) {
        event.stopPropagation();
        event.preventDefault();
        if (helpergrid.classList.contains("hidden")) {
            showGrid(gridtoggler, helpergrid);
        } else {
            hideGrid(gridtoggler, helpergrid);
        }
    });
};

/**
 * Helper function to remove the grid from imageboard.
 *
 * @param {object} button
 * @param {object} helpergrid
 */
function showGrid(button, helpergrid) {
    helpergrid.classList.remove("hidden");
    button.value = 'gridvisible';
    Str.get_string('buttonlabelhelpergridhide', 'unilabeltype_imageboard').done(function(text) {
        button.innerText = text;
    });
}

/**
 * Helper function to remove the grid from imageboard.
 *
 * @param {object} button
 * @param {object} helpergrid
 */
function hideGrid(button, helpergrid) {
    helpergrid.classList.add("hidden");
    button.value = 'gridhidden';
    Str.get_string('buttonlabelhelpergridshow', 'unilabeltype_imageboard').done(function(text) {
        button.innerText = text;
    });
}

/**
 * Helper function to get the width of the usable browserarea.
 *
 * @returns {*|number}
 */
function getWidth() {
    if (self.innerWidth) {
        return self.innerWidth;
    }
    if (document.documentElement && document.documentElement.clientWidth) {
        return document.documentElement.clientWidth;
    }
    if (document.body) {
        return document.body.clientWidth;
    }
    return 0;
}

/**
 * Resizes the imageboard when clicking the resize-button or while resizing the browser
 * @param {string} cmid
 * @param {string} canvaswidth
 * @param {string} canvasheight
 */
function resize(cmid, canvaswidth, canvasheight) {
    const imageboard = document.getElementById("unilabeltype-imageboard-" + cmid);
    const imageboardContainer = document.getElementById("unilabeltype-imageboard-container-" + cmid);

    let newcanvaswidth = 0;
    if (getWidth() > 770) {
        newcanvaswidth = (getWidth() - imageboard.getBoundingClientRect().left) - 70;
    } else {
        newcanvaswidth = (getWidth() - imageboard.getBoundingClientRect().left) - 20;
    }
    // Do not make backgroundimage larger than the configured width
    if (newcanvaswidth > canvaswidth) {
        newcanvaswidth = canvaswidth;
    }

    let widthfactor = newcanvaswidth / canvaswidth;

    const mydiv = document.getElementById("unilabeltype-imageboard-" + cmid);

    mydiv.style.transform = "scale(" + widthfactor + ")";
    mydiv.style.transformOrigin = "0 0";

    // Make the imageboardContainer just 20px larger than the imageboard.
    imageboardContainer.style.width = mydiv.offsetWidth * widthfactor + 20 + "px";

    // The height of the white space that is generated by scaling the div can be calculated
    let heightOfSpace = canvasheight * (1 - widthfactor);
    mydiv.style.marginBottom = "-" + heightOfSpace + "px";
}
